proto = Proto("IOP", "Interoperability Profiles");

-- field listed later in wireshark expression list
pf_messageid = ProtoField.uint16("iop.message_id", "Message ID", base.HEX)
pf_message_name = ProtoField.string("iop.message_name", "Message Name", base.STRING)
pf_sub_messageid = ProtoField.uint16("iop.event.message_id", "Event Message ID", base.HEX)
pf_msg_type = ProtoField.uint8("iop.message_type", "message_type", base.HEX, nil, 0x3F)
pf_hc_flags = ProtoField.uint8("iop.hc_flags", "hc_flags", base.HEX, nil, 0xC0)
pf_flags = ProtoField.uint8("iop.flags", "flags", base.HEX, nil, 0xFF)
pf_f_priority = ProtoField.uint8("iop.flags.priority", "Priority", base.HEX, {[0]="Low", [1]="Standard", [2]="High", [3]="Safety Critical"}, 0x3)
pf_f_bcast = ProtoField.uint8("iop.flags.bcast", "Broadcast", base.HEX, {[0]="No Broadcast", [1]="Local Broadcast", [2]="Global Broadcast"}, 0xC)
pf_f_acknak = ProtoField.uint8("iop.flags.acknack", "Acknak", base.HEX, {[0]="No response required", [1]="Response required", [2]="Message negative acknowledge", [3]="Message acknowledged OK"}, 0x30)
pf_f_data_flags = ProtoField.uint8("iop.flags.data_flags", "Data Flags", base.HEX, {[0]="Only data packet in single-packet stream", [1]="First data packet in multi-packet stream", [2]="Normal (middle) data packet", [3]="Last data packet in stream"}, 0xC0)
pf_src_subsystem_id = ProtoField.uint8("iop.src.subsystem", "Subsystem", base.LEDEC, nil)
pf_src_node_id = ProtoField.uint8("iop.src.node", "Node", base.DEC, nil)
pf_src_component_id = ProtoField.uint8("iop.src.component", "Component", base.DEC, nil)
pf_dst_subsystem_id = ProtoField.uint8("iop.dst.subsystem", "Subsystem", base.DEC, nil)
pf_dst_node_id = ProtoField.uint8("iop.dst.node", "Node", base.DEC, nil)
pf_dst_component_id = ProtoField.uint8("iop.dst.component", "Component", base.DEC, nil)


proto.fields = {
    pf_messageid,
    pf_message_name,
    pf_sub_messageid,
    pf_msg_type,
    pf_hc_flags,
    pf_flags,
    pf_f_priority,
    pf_f_bcast,
    pf_f_acknak,
    pf_f_data_flags,
    pf_src_subsystem_id,
    pf_src_node_id,
    pf_src_component_id,
    pf_dst_subsystem_id,
    pf_dst_node_id,
    pf_dst_component_id
}

-- this table is for autogenerated message dissector
messagetable = DissectorTable.new("iop.message_id", "IOP Message ID's", ftypes.UINT16, base.HEX)

local my_info = 
{
    version = "1.0.0",
    author = "Lukas Boes",
}
set_plugin_info(my_info)


function bitstr(value, bits_count)  -- creates a string with bit representation of an integer
    local t = {}
    idx = 0
    for i = 1, bits_count do
        rest = value % 2
        table.insert(t, 1, rest)
        idx = idx + 1
        if idx == 4 then
            idx = 0
            table.insert(t, 1, ' ')
        end
        value = (value - rest) / 2
    end
    return table.concat(t)
end


function bitstr_part(value, bits_count, start_pos, end_pos)  -- creates a string with bit representation of selected bits of an integer
    local t = {}
    idx = 0
    for i = 1, bits_count do
        rest = value % 2
        if start_pos <= idx and idx <= end_pos then
            table.insert(t, 1, rest)
        else
            table.insert(t, 1, '.')
        end
        idx = idx + 1
        if idx % 4 == 0 then
            table.insert(t, 1, ' ')
        end
        value = (value - rest) / 2
    end
    return table.concat(t)
end


function bitAND(value, bit_pos)  -- returns 1 or 0 at bit position `bit_pos` in given value
    local rest = 0
    for i = 0, bit_pos do
        rest = value % 2
        value = (value - rest) / 2
    end
    return rest
end


function bitVal(value, bit_start_pos, bit_end_pos)  -- returns number represented by bits from position `bit_start_pos` to position `bit_end_pos` in given value
    local t = {}
    for i = 1, bit_start_pos do
        rest = value % 2
        value = (value - rest) / 2
    end
    for i = bit_start_pos, bit_end_pos do
        rest = value % 2
        table.insert(t, 1, rest)
        value = (value - rest) / 2
    end
    return tonumber(table.concat(t), 2)
end


-- dissector for IOP message header
function proto.dissector(buffer, pinfo, tree)
    length = buffer:len()
    if length == 0 then return end

    pinfo.cols.protocol = proto.name

    local as5669a_length = buffer:len()
    -- create subtree
    local subtree = tree:add(proto, buffer(), string.format("IOP"))
    -- Adding fields to the tree
    subtree:add_le(buffer(0,1), string.format("Version: %d", buffer(0, 1):le_uint()))
    local hc_offset = 0
    subtree:add(pf_msg_type, buffer(1, 1))
    local hc_flag = bitVal(buffer(1, 1):le_uint(), 6, 7)
    subtree:add(pf_hc_flags, buffer(1, 1))
    if hc_flag == 0 then
        -- no compression
        local payloadsize = buffer(2, 2):le_uint()
        subtree:add_le(buffer(2, 2), "Data Size: " .. buffer(2, 2):le_uint())

        local PDFlagsSubtree = subtree:add(pf_flags, buffer(4, 1))
        PDFlagsSubtree:add(pf_f_priority, buffer(4, 1))
        PDFlagsSubtree:add(pf_f_bcast, buffer(4, 1))
        PDFlagsSubtree:add(pf_f_acknak, buffer(4, 1))
        PDFlagsSubtree:add(pf_f_data_flags, buffer(4, 1))

        src_id = string.format("%d.%d.%d", buffer(11, 2):le_uint(), buffer(10, 1):uint(), buffer(9, 1):uint())
        dst_id = string.format("%d.%d.%d", buffer(7, 2):le_uint(), buffer(6, 1):uint(), buffer(5, 1):uint())
        subtree:append_text(string.format(", Src: %s, Dst: %s", src_id, dst_id))
        -- add destiantion id
        local dst_id_subtree = subtree:add(buffer(5, 4), string.format("Destination ID: %s-%d", dst_id, buffer(5, 4):le_uint()))
        dst_id_subtree:add_le(pf_dst_subsystem_id, buffer(7, 2))
        dst_id_subtree:add(pf_dst_node_id, buffer(6, 1))
        dst_id_subtree:add(pf_dst_component_id, buffer(5, 1))
        -- add source id
        local src_id_subtree = subtree:add(buffer(9, 4), string.format("Source ID: %s-%d", src_id, buffer(9, 4):le_uint()))
        src_id_subtree:add_le(pf_src_subsystem_id, buffer(11, 2))
        src_id_subtree:add(pf_src_node_id, buffer(10, 1))
        src_id_subtree:add(pf_src_component_id, buffer(9, 1))
        -- add sequence number
        local seq_nr = buffer(as5669a_length-2, 2):le_uint()
        subtree:add_le(buffer(as5669a_length-2, 2), "Sequence Number: " .. seq_nr)
        -- parse included message
        local messageid = 0
        local id_str = "unknown"
        local flags_val = buffer(4, 1):le_uint()
        if bitAND(flags_val, 7) == 1 and bitAND(flags_val, 6) == 0 then
            id_str = "Middle Data Paket"
            subtree:append_text(string.format(", %s", id_str))
            pinfo.cols.info:set(string.format('[middle] %s->%s, SeqNr: %d', src_id, dst_id, seq_nr));
        elseif bitAND(flags_val, 7) == 1 and bitAND(flags_val, 6) == 1 then
            id_str = "Last Data Paket"
            subtree:append_text(string.format(", %s", id_str))
            pinfo.cols.info:set(string.format('[last] %s->%s, SeqNr: %d', src_id, dst_id, seq_nr));
        else
            -- add message id
            if as5669a_length-1 >= 16 then
                messageid = buffer(13, 2):le_uint()
            end
            subtree:add(pf_messageid, buffer(13, 2), messageid, string.format("Message ID: 0x%04X", messageid))
            -- update col info
            if bitAND(flags_val, 7) == 0 and bitAND(flags_val, 6) == 1 then
                pinfo.cols.info:set(string.format('0x%04X [first]', messageid));
            else
                pinfo.cols.info:set(string.format('0x%04X', messageid));
            end
            -- search for message dissector
            local packet_dissector = messagetable:get_dissector(messageid)
            if packet_dissector ~= nil then
                packet_dissector(buffer(13, buffer:len()-15):tvb(), pinfo, tree)
            end
            pinfo.cols.info:set(string.format("%s, %s->%s, SeqNr: %d", tostring(pinfo.cols.info), src_id, dst_id, seq_nr))
        end
    else
        -- handle compression
    end

end


local udp_port = DissectorTable.get("udp.port")
udp_port:add(3794, proto)
udp_port:add(55555, proto)
local tcp_port = DissectorTable.get("tcp.port")
tcp_port:add(3794, proto)

-- ############################
-- Generated Message Dissectors
-- ############################
